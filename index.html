<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>BASICdraw - Vintage BASIC Line Map Drawer</title>
    <style>
      body {
        background:#111;
        color:#ddd;
        font-family:'Courier New',monospace;
        text-align:center;
        padding:10px;
        margin:0;
      }
      h2 {
        margin:15px 0;
        color:#0f0;
        text-shadow:0 0 10px #0f0;
      }
      canvas {
        background:black;
        border:2px solid #555;
        display:block;
        margin:15px auto;
        box-shadow:0 0 20px rgba(0,255,0,0.2);
      }
      button {
        margin:5px;
        padding:8px 16px;
        background:#222;
        color:#0f0;
        border:2px solid #0f0;
        cursor:pointer;
        font-family:'Courier New',monospace;
        font-weight:bold;
        transition:all 0.2s;
      }
      button:hover {
        background:#0f0;
        color:#000;
      }
      select {
        margin:5px;
        padding:6px 10px;
        background:#222;
        color:#ddd;
        border:1px solid #555;
        font-family:'Courier New',monospace;
        font-size:13px;
      }
      .controls {
        margin:15px auto;
        max-width:900px;
        background:#1a1a1a;
        padding:15px;
        border:1px solid #333;
        border-radius:5px;
      }
      .control-group {
        display:inline-block;
        margin:8px 20px;
        text-align:left;
      }
      .control-group label {
        display:block;
        margin-bottom:5px;
        color:#888;
        font-size:11px;
        text-transform:uppercase;
        letter-spacing:1px;
      }
      #output {
        width:100%;
        max-width:900px;
        height:200px;
        margin:0;
        display:block;
        background:#000;
        color:#0f0;
        border:2px solid #0f0;
        font-family:'Courier New',monospace;
        padding:10px;
        box-sizing:border-box;
        font-size:13px;
        line-height:1.4;
      }
      .info {
        margin:10px auto;
        max-width:900px;
        font-size:12px;
        color:#666;
        font-style:italic;
      }
      .button-group {
        margin:15px 0;
      }
    </style>
  </head>
  <body>
    <h2>BASICdraw</h2>
    
    <div class="info" style="margin-bottom:15px;color:#888;max-width:700px;margin-left:auto;margin-right:auto;">
      Back in the day, programmers plotted graphics on graph paper before typing coordinates into BASIC. 
      This tool lets you draw directly and export authentic LINE commands for vintage BASIC dialects! No more graph paper!
    </div>
    
    <div class="controls">
      <div class="control-group">
        <label>BASIC Dialect:</label>
        <select id="dialect">
          <option value="gwbasic" selected>GW-BASIC / QBasic / QuickBASIC</option>
          <option value="atari">Atari ST BASIC</option>
          <option value="sharp">Sharp MZ-700/800 BASIC</option>
          <option value="msx">MSX BASIC</option>
          <option value="c128">Commodore 128 BASIC 7.0</option>
          <option value="apple2">Apple II HPLOT</option>
          <option value="generic">Generic BASIC</option>
        </select>
      </div>
      
      <div class="control-group">
        <label>Resolution:</label>
        <select id="resolution">
          <option value="256x192">256Ã—192 (MSX)</option>
          <option value="280x192">280Ã—192 (Apple II HGR2)</option>
          <option value="320x200">320Ã—200 (CGA/C64/Atari)</option>
          <option value="640x350">640Ã—350 (EGA)</option>
          <option value="640x400">640Ã—400 (Atari ST)</option>
          <option value="640x480" selected>640Ã—480 (VGA)</option>
        </select>
      </div>
      
      <div class="control-group">
        <label>Color:</label>
        <select id="color">
          <option value="0">0 - Black</option>
          <option value="1">1 - Blue</option>
          <option value="2">2 - Green</option>
          <option value="3">3 - Cyan</option>
          <option value="4">4 - Red</option>
          <option value="5">5 - Magenta</option>
          <option value="6">6 - Brown</option>
          <option value="7">7 - Light Gray</option>
          <option value="8">8 - Dark Gray</option>
          <option value="9">9 - Light Blue</option>
          <option value="10">10 - Light Green</option>
          <option value="11">11 - Light Cyan</option>
          <option value="12">12 - Light Red</option>
          <option value="13">13 - Light Magenta</option>
          <option value="14">14 - Yellow</option>
          <option value="15" selected>15 - White</option>
        </select>
      </div>
      
      <div class="control-group">
        <label>Line starts at:</label>
        <input type="number" id="linestart" value="10" min="1" step="10" style="width:80px;padding:6px;background:#222;color:#ddd;border:1px solid #555;font-family:'Courier New',monospace;">
      </div>
    </div>
    
    <div class="controls" style="margin-top:10px;">
      <div class="control-group">
        <label>Image Overlay:</label>
        <input type="file" id="overlayFile" accept="image/*" style="display:none;">
        <button id="loadOverlay" style="margin:0;padding:6px 12px;font-size:12px;">ðŸ“· Load Image</button>
      </div>
      
      <div class="control-group" id="overlayControls" style="display:none;">
        <label>Opacity:</label>
        <input type="range" id="overlayOpacity" min="0" max="100" value="50" style="width:100px;vertical-align:middle;">
        <span id="opacityValue" style="margin-left:5px;color:#888;font-size:11px;">50%</span>
      </div>
      
      <div class="control-group" id="removeOverlayGroup" style="display:none;">
        <label>&nbsp;</label>
        <button id="removeOverlay" style="margin:0;padding:6px 12px;font-size:12px;">âœ• Remove</button>
      </div>
    </div>
    
    <canvas id="map"></canvas>
    
    <div class="button-group">
      <button id="newseg">âŠ™ New Segment</button>
      <button id="undo">â†¶ Undo</button>
      <button id="export">â‡“ Export BASIC Code</button>
      <button id="clear">âœ• Clear Canvas</button>
    </div>
    
    <div class="info">
      Click on canvas to draw points. Lines connect consecutive points. Use "New Segment" to start disconnected line.
    </div>
    
    <div style="position:relative;max-width:900px;margin:15px auto;">
      <textarea id="output" readonly placeholder="Your BASIC LINE commands will appear here..."></textarea>
      <button id="copy" style="position:absolute;top:10px;right:10px;padding:5px 10px;font-size:11px;">ðŸ“‹ Copy</button>
    </div>
    
    <div style="margin-top:20px;padding:15px;font-size:11px;color:#555;border-top:1px solid #222;">
      Made by <a href="https://1xn.org" target="_blank" style="color:#0f0;text-decoration:none;">1XN.org</a> | 
      <a href="https://github.com/1xn" target="_blank" style="color:#0f0;text-decoration:none;">GitHub: 1xn</a>
    </div>
    
    <script>
      const canvas = document.getElementById("map");
      const ctx = canvas.getContext("2d");
      const output = document.getElementById("output");
      const resSelect = document.getElementById("resolution");
      const dialectSelect = document.getElementById("dialect");
      const colorSelect = document.getElementById("color");
      
      // EGA/VGA 16-color palette
      const egaColors = {
        0: { name: "Black", rgb: [0, 0, 0], hex: "#000000" },
        1: { name: "Blue", rgb: [0, 0, 170], hex: "#0000AA" },
        2: { name: "Green", rgb: [0, 170, 0], hex: "#00AA00" },
        3: { name: "Cyan", rgb: [0, 170, 170], hex: "#00AAAA" },
        4: { name: "Red", rgb: [170, 0, 0], hex: "#AA0000" },
        5: { name: "Magenta", rgb: [170, 0, 170], hex: "#AA00AA" },
        6: { name: "Brown", rgb: [170, 85, 0], hex: "#AA5500" },
        7: { name: "Light Gray", rgb: [170, 170, 170], hex: "#AAAAAA" },
        8: { name: "Dark Gray", rgb: [85, 85, 85], hex: "#555555" },
        9: { name: "Light Blue", rgb: [85, 85, 255], hex: "#5555FF" },
        10: { name: "Light Green", rgb: [85, 255, 85], hex: "#55FF55" },
        11: { name: "Light Cyan", rgb: [85, 255, 255], hex: "#55FFFF" },
        12: { name: "Light Red", rgb: [255, 85, 85], hex: "#FF5555" },
        13: { name: "Light Magenta", rgb: [255, 85, 255], hex: "#FF55FF" },
        14: { name: "Yellow", rgb: [255, 255, 85], hex: "#FFFF55" },
        15: { name: "White", rgb: [255, 255, 255], hex: "#FFFFFF" }
      };
      
      // Dialect configurations
      const dialects = {
        generic: {
          name: "Generic BASIC",
          format: (x1, y1, x2, y2, color) => `LINE ${x1},${y1} TO ${x2},${y2},${color}`,
          resolutions: ["256x192", "320x200", "640x350", "640x400", "640x480"]
        },
        atari: {
          name: "Atari ST BASIC",
          format: (x1, y1, x2, y2, color) => `LINE (${x1},${y1})-(${x2},${y2}),${color}`,
          resolutions: ["320x200", "640x400"]
        },
        gwbasic: {
          name: "GW-BASIC / QBasic / QuickBASIC",
          format: (x1, y1, x2, y2, color) => `LINE (${x1},${y1})-(${x2},${y2}),${color}`,
          resolutions: ["320x200", "640x350", "640x480"]
        },
        sharp: {
          name: "Sharp MZ-700/800 BASIC",
          format: (x1, y1, x2, y2, color) => `LINE (${x1},${y1})-(${x2},${y2}),${color}`,
          resolutions: ["320x200"]
        },
        msx: {
          name: "MSX BASIC",
          format: (x1, y1, x2, y2, color) => `LINE (${x1},${y1})-(${x2},${y2}),${color}`,
          resolutions: ["256x192"]
        },
        c128: {
          name: "Commodore 128 BASIC 7.0",
          format: (x1, y1, x2, y2, color) => `LINE (${x1},${y1})-(${x2},${y2}),${color}`,
          resolutions: ["320x200"]
        },
        apple2: {
          name: "Apple II HPLOT",
          format: (x1, y1, x2, y2, color) => {
            // Apple II uses HCOLOR= separately, not as parameter
            const appleColor = mapEgaToApple2Color(color);
            return `HCOLOR=${appleColor}\nHPLOT ${x1},${y1} TO ${x2},${y2}`;
          },
          resolutions: ["280x192"]
        }
      };
      
      // Map EGA/VGA colors (0-15) to Apple II hi-res colors (0-7)
      function mapEgaToApple2Color(egaColor) {
        const mapping = {
          0: 0,   // Black -> Black
          1: 6,   // Blue -> Blue
          2: 1,   // Green -> Green
          3: 6,   // Cyan -> Blue (closest)
          4: 5,   // Red -> Orange (closest)
          5: 2,   // Magenta -> Violet
          6: 5,   // Brown -> Orange
          7: 3,   // Light Gray -> White
          8: 0,   // Dark Gray -> Black
          9: 6,   // Light Blue -> Blue
          10: 1,  // Light Green -> Green
          11: 6,  // Light Cyan -> Blue
          12: 5,  // Light Red -> Orange
          13: 2,  // Light Magenta -> Violet
          14: 5,  // Yellow -> Orange
          15: 3   // White -> White
        };
        return mapping[egaColor] !== undefined ? mapping[egaColor] : 3; // Default to white
      }
      
      let last = null;
      let lines = []; // Each line: [x1, y1, x2, y2, color]
      let currentRes = {w: 640, h: 480}; // Default matches GW-BASIC VGA resolution
      let overlayImage = null;
      let overlayOpacity = 0.5; // 0-1 range
      
      function getCurrentColor() {
        return parseInt(colorSelect.value) || 15;
      }
      
      function getColorHex(colorIndex) {
        return egaColors[colorIndex]?.hex || "#FFFFFF";
      }
      
      function parseResolution(resStr) {
        const [w, h] = resStr.split('x').map(Number);
        return {w, h};
      }
      
      function setResolution() {
        const res = resSelect.value;
        currentRes = parseResolution(res);
        canvas.width = currentRes.w;
        canvas.height = currentRes.h;
        // Redraw with overlay if present
        redrawCanvas();
        lines = [];
        last = null;
        output.value = "";
      }
      
      function grid() {
        const gridX = currentRes.w / 8;
        const gridY = currentRes.h / 8;
        
        ctx.strokeStyle = "#003366";
        ctx.lineWidth = 1;
        
        for (let x = 0; x <= currentRes.w; x += gridX) {
          ctx.beginPath(); 
          ctx.moveTo(x, 0); 
          ctx.lineTo(x, currentRes.h); 
          ctx.stroke();
        }
        for (let y = 0; y <= currentRes.h; y += gridY) {
          ctx.beginPath(); 
          ctx.moveTo(0, y); 
          ctx.lineTo(currentRes.w, y); 
          ctx.stroke();
        }
        
        ctx.strokeStyle = "#00ff00";
        ctx.lineWidth = 2;
      }
      
      function reset() {
        ctx.clearRect(0, 0, currentRes.w, currentRes.h);
        // Note: Don't clear overlay image on reset, just redraw
        redrawCanvas();
        lines = [];
        last = null;
        output.value = "";
      }
      
      function formatLine(x1, y1, x2, y2, color, lineNum) {
        const dialect = dialectSelect.value;
        const formatted = dialects[dialect].format(x1, y1, x2, y2, color);
        return `${lineNum} ${formatted}`;
      }
      
      function redrawCanvas() {
        ctx.clearRect(0, 0, currentRes.w, currentRes.h);
        
        // Draw overlay image if present (before grid)
        if (overlayImage) {
          ctx.save();
          ctx.globalAlpha = overlayOpacity;
          
          // Calculate scaled dimensions to fit canvas width while maintaining aspect ratio
          const scale = currentRes.w / overlayImage.width;
          const scaledWidth = currentRes.w;
          const scaledHeight = overlayImage.height * scale;
          
          // Center vertically
          const yOffset = (currentRes.h - scaledHeight) / 2;
          
          ctx.drawImage(overlayImage, 0, yOffset, scaledWidth, scaledHeight);
          ctx.restore();
        }
        
        grid();
        
        // Redraw all lines with their stored colors
        for (const [x1, y1, x2, y2, color] of lines) {
          const colorHex = getColorHex(color);
          ctx.strokeStyle = colorHex;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          
          // Redraw points
          ctx.fillStyle = colorHex;
          ctx.fillRect(x1 - 2, y1 - 2, 5, 5);
          ctx.fillRect(x2 - 2, y2 - 2, 5, 5);
        }
        
        // Draw the last point if it exists (for cases where a point is placed but no line drawn yet)
        if (last) {
          const currentColor = getCurrentColor();
          const colorHex = getColorHex(currentColor);
          ctx.fillStyle = colorHex;
          ctx.fillRect(last.x - 2, last.y - 2, 5, 5);
        }
        
        // Reset stroke style for grid
        ctx.strokeStyle = "#00ff00";
        ctx.lineWidth = 2;
      }
      
      function updateResolutionOptions() {
        const dialect = dialectSelect.value;
        const validRes = dialects[dialect].resolutions;
        const currentValue = resSelect.value;
        
        // Check if current resolution is valid for selected dialect
        if (!validRes.includes(currentValue)) {
          // Switch to first valid resolution for this dialect
          resSelect.value = validRes[0];
          setResolution();
        }
      }
      
      // Initialize canvas with default resolution
      canvas.width = currentRes.w;
      canvas.height = currentRes.h;
      grid();
      
      canvas.addEventListener("click", e => {
        const rect = canvas.getBoundingClientRect();
        const scaleX = currentRes.w / rect.width;
        const scaleY = currentRes.h / rect.height;
        const x = Math.floor((e.clientX - rect.left) * scaleX);
        const y = Math.floor((e.clientY - rect.top) * scaleY);
        const currentColor = getCurrentColor();
        const colorHex = getColorHex(currentColor);
        
        ctx.fillStyle = colorHex;
        ctx.fillRect(x - 2, y - 2, 5, 5);
        
        if (last) {
          ctx.strokeStyle = colorHex;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(last.x, last.y);
          ctx.lineTo(x, y);
          ctx.stroke();
          lines.push([last.x, last.y, x, y, currentColor]);
        }
        last = {x, y};
      });
      
      document.getElementById("newseg").onclick = () => { 
        last = null;
      };
      
      document.getElementById("undo").onclick = () => {
        if (lines.length === 0) {
          // No lines to undo, but we might have a single point
          if (last) {
            // Remove the last point by clearing and redrawing
            last = null;
            redrawCanvas();
            output.value = "";
          }
          return;
        }
        
        // Remove the last line
        const removedLine = lines.pop();
        const [x1, y1, x2, y2, color] = removedLine;
        
        // Update last to be the starting point of the removed line
        // This allows continuing from where we were before the undo
        last = {x: x1, y: y1};
        
        // Redraw the canvas without the removed line
        redrawCanvas();
        
        // Clear export output since it's now outdated
        output.value = "";
      };
      
      document.getElementById("export").onclick = () => {
        const startLine = parseInt(document.getElementById("linestart").value) || 10;
        const dialect = dialectSelect.value;
        let text = "";
        let lineNum = startLine;
        
        // Apple II needs special handling - HCOLOR= and HPLOT are separate lines
        if (dialect === "apple2") {
          let lastAppleColor = null;
          for (let i = 0; i < lines.length; i++) {
            const [x1, y1, x2, y2, color] = lines[i];
            const appleColor = mapEgaToApple2Color(color);
            // Only output HCOLOR= when color changes
            if (appleColor !== lastAppleColor) {
              text += `${lineNum} HCOLOR=${appleColor}\n`;
              lineNum += 10;
              lastAppleColor = appleColor;
            }
            text += `${lineNum} HPLOT ${x1},${y1} TO ${x2},${y2}\n`;
            lineNum += 10;
          }
        } else {
          for (let i = 0; i < lines.length; i++) {
            const [x1, y1, x2, y2, color] = lines[i];
            text += formatLine(x1, y1, x2, y2, color, lineNum) + "\n";
            lineNum += 10;
          }
        }
        
        output.value = text || "No lines drawn yet. Click on the canvas to start drawing!";
      };
      
      // Redraw canvas when color changes (for visual feedback)
      colorSelect.addEventListener("change", () => {
        // Visual feedback: the next line will use the new color
        // Existing lines keep their colors
      });
      
      document.getElementById("clear").onclick = reset;
      
      document.getElementById("copy").onclick = () => {
        const textarea = document.getElementById("output");
        const text = textarea.value;
        if (!text || text === "No lines drawn yet. Click on the canvas to start drawing!" || text === "" || text === "Your BASIC LINE commands will appear here...") {
          return;
        }
        
        // Select the textarea content and copy
        textarea.select();
        textarea.setSelectionRange(0, 99999); // For mobile devices
        
        try {
          document.execCommand('copy');
          const btn = document.getElementById("copy");
          const original = btn.textContent;
          btn.textContent = "âœ“ Copied!";
          btn.style.background = "#0f0";
          btn.style.color = "#000";
          setTimeout(() => {
            btn.textContent = original;
            btn.style.background = "#222";
            btn.style.color = "#0f0";
          }, 1500);
        } catch (err) {
          // Fallback to clipboard API
          navigator.clipboard.writeText(text).then(() => {
            const btn = document.getElementById("copy");
            const original = btn.textContent;
            btn.textContent = "âœ“ Copied!";
            btn.style.background = "#0f0";
            btn.style.color = "#000";
            setTimeout(() => {
              btn.textContent = original;
              btn.style.background = "#222";
              btn.style.color = "#0f0";
            }, 1500);
          });
        }
      };
      
      resSelect.addEventListener("change", setResolution);
      dialectSelect.addEventListener("change", updateResolutionOptions);
      
      // Overlay image functionality
      const overlayFileInput = document.getElementById("overlayFile");
      const loadOverlayBtn = document.getElementById("loadOverlay");
      const removeOverlayBtn = document.getElementById("removeOverlay");
      const overlayOpacitySlider = document.getElementById("overlayOpacity");
      const opacityValueSpan = document.getElementById("opacityValue");
      const overlayControls = document.getElementById("overlayControls");
      const removeOverlayGroup = document.getElementById("removeOverlayGroup");
      
      loadOverlayBtn.addEventListener("click", () => {
        overlayFileInput.click();
      });
      
      overlayFileInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
              overlayImage = img;
              overlayControls.style.display = "inline-block";
              removeOverlayGroup.style.display = "inline-block";
              redrawCanvas();
            };
            img.src = event.target.result;
          };
          reader.readAsDataURL(file);
        }
      });
      
      overlayOpacitySlider.addEventListener("input", (e) => {
        overlayOpacity = e.target.value / 100;
        opacityValueSpan.textContent = e.target.value + "%";
        redrawCanvas();
      });
      
      removeOverlayBtn.addEventListener("click", () => {
        overlayImage = null;
        overlayFileInput.value = "";
        overlayControls.style.display = "none";
        removeOverlayGroup.style.display = "none";
        redrawCanvas();
      });
    </script>
  </body>
</html>